// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: econ.proto

#ifndef PROTOBUF_econ_2eproto__INCLUDED
#define PROTOBUF_econ_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_econ_2eproto();
void protobuf_AssignDesc_econ_2eproto();
void protobuf_ShutdownFile_econ_2eproto();

class Item;
class Inventory;
class Strategy;
class EconAgent;
class Ingredient;
class Recipe;
class World;

// ===================================================================

class Item : public ::google::protobuf::Message {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item& default_instance();

  void Swap(Item* other);

  // implements Message ----------------------------------------------

  Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 defense = 3;
  inline bool has_defense() const;
  inline void clear_defense();
  static const int kDefenseFieldNumber = 3;
  inline ::google::protobuf::int32 defense() const;
  inline void set_defense(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.Item)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_defense();
  inline void clear_has_defense();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 defense_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_econ_2eproto();
  friend void protobuf_AssignDesc_econ_2eproto();
  friend void protobuf_ShutdownFile_econ_2eproto();

  void InitAsDefaultInstance();
  static Item* default_instance_;
};
// -------------------------------------------------------------------

class Inventory : public ::google::protobuf::Message {
 public:
  Inventory();
  virtual ~Inventory();

  Inventory(const Inventory& from);

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Inventory& default_instance();

  void Swap(Inventory* other);

  // implements Message ----------------------------------------------

  Inventory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Inventory& from);
  void MergeFrom(const Inventory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 coin = 1;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 1;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // repeated .proto.Item items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::proto::Item& items(int index) const;
  inline ::proto::Item* mutable_items(int index);
  inline ::proto::Item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::Item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::Item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:proto.Inventory)
 private:
  inline void set_has_coin();
  inline void clear_has_coin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::Item > items_;
  ::google::protobuf::int32 coin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_econ_2eproto();
  friend void protobuf_AssignDesc_econ_2eproto();
  friend void protobuf_ShutdownFile_econ_2eproto();

  void InitAsDefaultInstance();
  static Inventory* default_instance_;
};
// -------------------------------------------------------------------

class Strategy : public ::google::protobuf::Message {
 public:
  Strategy();
  virtual ~Strategy();

  Strategy(const Strategy& from);

  inline Strategy& operator=(const Strategy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Strategy& default_instance();

  void Swap(Strategy* other);

  // implements Message ----------------------------------------------

  Strategy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Strategy& from);
  void MergeFrom(const Strategy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double param1 = 1;
  inline bool has_param1() const;
  inline void clear_param1();
  static const int kParam1FieldNumber = 1;
  inline double param1() const;
  inline void set_param1(double value);

  // required double param2 = 2;
  inline bool has_param2() const;
  inline void clear_param2();
  static const int kParam2FieldNumber = 2;
  inline double param2() const;
  inline void set_param2(double value);

  // required double param3 = 3;
  inline bool has_param3() const;
  inline void clear_param3();
  static const int kParam3FieldNumber = 3;
  inline double param3() const;
  inline void set_param3(double value);

  // required double param4 = 4;
  inline bool has_param4() const;
  inline void clear_param4();
  static const int kParam4FieldNumber = 4;
  inline double param4() const;
  inline void set_param4(double value);

  // required double param5 = 5;
  inline bool has_param5() const;
  inline void clear_param5();
  static const int kParam5FieldNumber = 5;
  inline double param5() const;
  inline void set_param5(double value);

  // required double param6 = 6;
  inline bool has_param6() const;
  inline void clear_param6();
  static const int kParam6FieldNumber = 6;
  inline double param6() const;
  inline void set_param6(double value);

  // required double param7 = 7;
  inline bool has_param7() const;
  inline void clear_param7();
  static const int kParam7FieldNumber = 7;
  inline double param7() const;
  inline void set_param7(double value);

  // required double param8 = 8;
  inline bool has_param8() const;
  inline void clear_param8();
  static const int kParam8FieldNumber = 8;
  inline double param8() const;
  inline void set_param8(double value);

  // @@protoc_insertion_point(class_scope:proto.Strategy)
 private:
  inline void set_has_param1();
  inline void clear_has_param1();
  inline void set_has_param2();
  inline void clear_has_param2();
  inline void set_has_param3();
  inline void clear_has_param3();
  inline void set_has_param4();
  inline void clear_has_param4();
  inline void set_has_param5();
  inline void clear_has_param5();
  inline void set_has_param6();
  inline void clear_has_param6();
  inline void set_has_param7();
  inline void clear_has_param7();
  inline void set_has_param8();
  inline void clear_has_param8();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double param1_;
  double param2_;
  double param3_;
  double param4_;
  double param5_;
  double param6_;
  double param7_;
  double param8_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_econ_2eproto();
  friend void protobuf_AssignDesc_econ_2eproto();
  friend void protobuf_ShutdownFile_econ_2eproto();

  void InitAsDefaultInstance();
  static Strategy* default_instance_;
};
// -------------------------------------------------------------------

class EconAgent : public ::google::protobuf::Message {
 public:
  EconAgent();
  virtual ~EconAgent();

  EconAgent(const EconAgent& from);

  inline EconAgent& operator=(const EconAgent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EconAgent& default_instance();

  void Swap(EconAgent* other);

  // implements Message ----------------------------------------------

  EconAgent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EconAgent& from);
  void MergeFrom(const EconAgent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 aid = 1;
  inline bool has_aid() const;
  inline void clear_aid();
  static const int kAidFieldNumber = 1;
  inline ::google::protobuf::int32 aid() const;
  inline void set_aid(::google::protobuf::int32 value);

  // required .proto.Inventory inventory = 2;
  inline bool has_inventory() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 2;
  inline const ::proto::Inventory& inventory() const;
  inline ::proto::Inventory* mutable_inventory();
  inline ::proto::Inventory* release_inventory();
  inline void set_allocated_inventory(::proto::Inventory* inventory);

  // required .proto.Strategy strategy = 3;
  inline bool has_strategy() const;
  inline void clear_strategy();
  static const int kStrategyFieldNumber = 3;
  inline const ::proto::Strategy& strategy() const;
  inline ::proto::Strategy* mutable_strategy();
  inline ::proto::Strategy* release_strategy();
  inline void set_allocated_strategy(::proto::Strategy* strategy);

  // @@protoc_insertion_point(class_scope:proto.EconAgent)
 private:
  inline void set_has_aid();
  inline void clear_has_aid();
  inline void set_has_inventory();
  inline void clear_has_inventory();
  inline void set_has_strategy();
  inline void clear_has_strategy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::Inventory* inventory_;
  ::proto::Strategy* strategy_;
  ::google::protobuf::int32 aid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_econ_2eproto();
  friend void protobuf_AssignDesc_econ_2eproto();
  friend void protobuf_ShutdownFile_econ_2eproto();

  void InitAsDefaultInstance();
  static EconAgent* default_instance_;
};
// -------------------------------------------------------------------

class Ingredient : public ::google::protobuf::Message {
 public:
  Ingredient();
  virtual ~Ingredient();

  Ingredient(const Ingredient& from);

  inline Ingredient& operator=(const Ingredient& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ingredient& default_instance();

  void Swap(Ingredient* other);

  // implements Message ----------------------------------------------

  Ingredient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ingredient& from);
  void MergeFrom(const Ingredient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.Ingredient)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_econ_2eproto();
  friend void protobuf_AssignDesc_econ_2eproto();
  friend void protobuf_ShutdownFile_econ_2eproto();

  void InitAsDefaultInstance();
  static Ingredient* default_instance_;
};
// -------------------------------------------------------------------

class Recipe : public ::google::protobuf::Message {
 public:
  Recipe();
  virtual ~Recipe();

  Recipe(const Recipe& from);

  inline Recipe& operator=(const Recipe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Recipe& default_instance();

  void Swap(Recipe* other);

  // implements Message ----------------------------------------------

  Recipe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Recipe& from);
  void MergeFrom(const Recipe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 output_item_id = 2;
  inline bool has_output_item_id() const;
  inline void clear_output_item_id();
  static const int kOutputItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 output_item_id() const;
  inline void set_output_item_id(::google::protobuf::int32 value);

  // repeated .proto.Ingredient ingredients = 3;
  inline int ingredients_size() const;
  inline void clear_ingredients();
  static const int kIngredientsFieldNumber = 3;
  inline const ::proto::Ingredient& ingredients(int index) const;
  inline ::proto::Ingredient* mutable_ingredients(int index);
  inline ::proto::Ingredient* add_ingredients();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::Ingredient >&
      ingredients() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::Ingredient >*
      mutable_ingredients();

  // @@protoc_insertion_point(class_scope:proto.Recipe)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_output_item_id();
  inline void clear_has_output_item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 output_item_id_;
  ::google::protobuf::RepeatedPtrField< ::proto::Ingredient > ingredients_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_econ_2eproto();
  friend void protobuf_AssignDesc_econ_2eproto();
  friend void protobuf_ShutdownFile_econ_2eproto();

  void InitAsDefaultInstance();
  static Recipe* default_instance_;
};
// -------------------------------------------------------------------

class World : public ::google::protobuf::Message {
 public:
  World();
  virtual ~World();

  World(const World& from);

  inline World& operator=(const World& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const World& default_instance();

  void Swap(World* other);

  // implements Message ----------------------------------------------

  World* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const World& from);
  void MergeFrom(const World& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Item armors = 1;
  inline int armors_size() const;
  inline void clear_armors();
  static const int kArmorsFieldNumber = 1;
  inline const ::proto::Item& armors(int index) const;
  inline ::proto::Item* mutable_armors(int index);
  inline ::proto::Item* add_armors();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::Item >&
      armors() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::Item >*
      mutable_armors();

  // repeated .proto.Item crafting_materials = 2;
  inline int crafting_materials_size() const;
  inline void clear_crafting_materials();
  static const int kCraftingMaterialsFieldNumber = 2;
  inline const ::proto::Item& crafting_materials(int index) const;
  inline ::proto::Item* mutable_crafting_materials(int index);
  inline ::proto::Item* add_crafting_materials();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::Item >&
      crafting_materials() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::Item >*
      mutable_crafting_materials();

  // repeated .proto.Recipe recipes = 3;
  inline int recipes_size() const;
  inline void clear_recipes();
  static const int kRecipesFieldNumber = 3;
  inline const ::proto::Recipe& recipes(int index) const;
  inline ::proto::Recipe* mutable_recipes(int index);
  inline ::proto::Recipe* add_recipes();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::Recipe >&
      recipes() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::Recipe >*
      mutable_recipes();

  // @@protoc_insertion_point(class_scope:proto.World)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::Item > armors_;
  ::google::protobuf::RepeatedPtrField< ::proto::Item > crafting_materials_;
  ::google::protobuf::RepeatedPtrField< ::proto::Recipe > recipes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_econ_2eproto();
  friend void protobuf_AssignDesc_econ_2eproto();
  friend void protobuf_ShutdownFile_econ_2eproto();

  void InitAsDefaultInstance();
  static World* default_instance_;
};
// ===================================================================


// ===================================================================

// Item

// required int32 id = 1;
inline bool Item::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Item::id() const {
  return id_;
}
inline void Item::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool Item::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Item::name() const {
  return *name_;
}
inline void Item::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Item::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Item::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Item::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Item::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Item::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 defense = 3;
inline bool Item::has_defense() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item::set_has_defense() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item::clear_has_defense() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item::clear_defense() {
  defense_ = 0;
  clear_has_defense();
}
inline ::google::protobuf::int32 Item::defense() const {
  return defense_;
}
inline void Item::set_defense(::google::protobuf::int32 value) {
  set_has_defense();
  defense_ = value;
}

// -------------------------------------------------------------------

// Inventory

// required int32 coin = 1;
inline bool Inventory::has_coin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Inventory::set_has_coin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Inventory::clear_has_coin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Inventory::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 Inventory::coin() const {
  return coin_;
}
inline void Inventory::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// repeated .proto.Item items = 2;
inline int Inventory::items_size() const {
  return items_.size();
}
inline void Inventory::clear_items() {
  items_.Clear();
}
inline const ::proto::Item& Inventory::items(int index) const {
  return items_.Get(index);
}
inline ::proto::Item* Inventory::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::proto::Item* Inventory::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Item >&
Inventory::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Item >*
Inventory::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// Strategy

// required double param1 = 1;
inline bool Strategy::has_param1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Strategy::set_has_param1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Strategy::clear_has_param1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Strategy::clear_param1() {
  param1_ = 0;
  clear_has_param1();
}
inline double Strategy::param1() const {
  return param1_;
}
inline void Strategy::set_param1(double value) {
  set_has_param1();
  param1_ = value;
}

// required double param2 = 2;
inline bool Strategy::has_param2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Strategy::set_has_param2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Strategy::clear_has_param2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Strategy::clear_param2() {
  param2_ = 0;
  clear_has_param2();
}
inline double Strategy::param2() const {
  return param2_;
}
inline void Strategy::set_param2(double value) {
  set_has_param2();
  param2_ = value;
}

// required double param3 = 3;
inline bool Strategy::has_param3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Strategy::set_has_param3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Strategy::clear_has_param3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Strategy::clear_param3() {
  param3_ = 0;
  clear_has_param3();
}
inline double Strategy::param3() const {
  return param3_;
}
inline void Strategy::set_param3(double value) {
  set_has_param3();
  param3_ = value;
}

// required double param4 = 4;
inline bool Strategy::has_param4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Strategy::set_has_param4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Strategy::clear_has_param4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Strategy::clear_param4() {
  param4_ = 0;
  clear_has_param4();
}
inline double Strategy::param4() const {
  return param4_;
}
inline void Strategy::set_param4(double value) {
  set_has_param4();
  param4_ = value;
}

// required double param5 = 5;
inline bool Strategy::has_param5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Strategy::set_has_param5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Strategy::clear_has_param5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Strategy::clear_param5() {
  param5_ = 0;
  clear_has_param5();
}
inline double Strategy::param5() const {
  return param5_;
}
inline void Strategy::set_param5(double value) {
  set_has_param5();
  param5_ = value;
}

// required double param6 = 6;
inline bool Strategy::has_param6() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Strategy::set_has_param6() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Strategy::clear_has_param6() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Strategy::clear_param6() {
  param6_ = 0;
  clear_has_param6();
}
inline double Strategy::param6() const {
  return param6_;
}
inline void Strategy::set_param6(double value) {
  set_has_param6();
  param6_ = value;
}

// required double param7 = 7;
inline bool Strategy::has_param7() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Strategy::set_has_param7() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Strategy::clear_has_param7() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Strategy::clear_param7() {
  param7_ = 0;
  clear_has_param7();
}
inline double Strategy::param7() const {
  return param7_;
}
inline void Strategy::set_param7(double value) {
  set_has_param7();
  param7_ = value;
}

// required double param8 = 8;
inline bool Strategy::has_param8() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Strategy::set_has_param8() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Strategy::clear_has_param8() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Strategy::clear_param8() {
  param8_ = 0;
  clear_has_param8();
}
inline double Strategy::param8() const {
  return param8_;
}
inline void Strategy::set_param8(double value) {
  set_has_param8();
  param8_ = value;
}

// -------------------------------------------------------------------

// EconAgent

// required int32 aid = 1;
inline bool EconAgent::has_aid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EconAgent::set_has_aid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EconAgent::clear_has_aid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EconAgent::clear_aid() {
  aid_ = 0;
  clear_has_aid();
}
inline ::google::protobuf::int32 EconAgent::aid() const {
  return aid_;
}
inline void EconAgent::set_aid(::google::protobuf::int32 value) {
  set_has_aid();
  aid_ = value;
}

// required .proto.Inventory inventory = 2;
inline bool EconAgent::has_inventory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EconAgent::set_has_inventory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EconAgent::clear_has_inventory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EconAgent::clear_inventory() {
  if (inventory_ != NULL) inventory_->::proto::Inventory::Clear();
  clear_has_inventory();
}
inline const ::proto::Inventory& EconAgent::inventory() const {
  return inventory_ != NULL ? *inventory_ : *default_instance_->inventory_;
}
inline ::proto::Inventory* EconAgent::mutable_inventory() {
  set_has_inventory();
  if (inventory_ == NULL) inventory_ = new ::proto::Inventory;
  return inventory_;
}
inline ::proto::Inventory* EconAgent::release_inventory() {
  clear_has_inventory();
  ::proto::Inventory* temp = inventory_;
  inventory_ = NULL;
  return temp;
}
inline void EconAgent::set_allocated_inventory(::proto::Inventory* inventory) {
  delete inventory_;
  inventory_ = inventory;
  if (inventory) {
    set_has_inventory();
  } else {
    clear_has_inventory();
  }
}

// required .proto.Strategy strategy = 3;
inline bool EconAgent::has_strategy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EconAgent::set_has_strategy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EconAgent::clear_has_strategy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EconAgent::clear_strategy() {
  if (strategy_ != NULL) strategy_->::proto::Strategy::Clear();
  clear_has_strategy();
}
inline const ::proto::Strategy& EconAgent::strategy() const {
  return strategy_ != NULL ? *strategy_ : *default_instance_->strategy_;
}
inline ::proto::Strategy* EconAgent::mutable_strategy() {
  set_has_strategy();
  if (strategy_ == NULL) strategy_ = new ::proto::Strategy;
  return strategy_;
}
inline ::proto::Strategy* EconAgent::release_strategy() {
  clear_has_strategy();
  ::proto::Strategy* temp = strategy_;
  strategy_ = NULL;
  return temp;
}
inline void EconAgent::set_allocated_strategy(::proto::Strategy* strategy) {
  delete strategy_;
  strategy_ = strategy;
  if (strategy) {
    set_has_strategy();
  } else {
    clear_has_strategy();
  }
}

// -------------------------------------------------------------------

// Ingredient

// required int32 item_id = 1;
inline bool Ingredient::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ingredient::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ingredient::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ingredient::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 Ingredient::item_id() const {
  return item_id_;
}
inline void Ingredient::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// required int32 count = 2;
inline bool Ingredient::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ingredient::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ingredient::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ingredient::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Ingredient::count() const {
  return count_;
}
inline void Ingredient::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// Recipe

// required int32 id = 1;
inline bool Recipe::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Recipe::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Recipe::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Recipe::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Recipe::id() const {
  return id_;
}
inline void Recipe::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 output_item_id = 2;
inline bool Recipe::has_output_item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Recipe::set_has_output_item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Recipe::clear_has_output_item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Recipe::clear_output_item_id() {
  output_item_id_ = 0;
  clear_has_output_item_id();
}
inline ::google::protobuf::int32 Recipe::output_item_id() const {
  return output_item_id_;
}
inline void Recipe::set_output_item_id(::google::protobuf::int32 value) {
  set_has_output_item_id();
  output_item_id_ = value;
}

// repeated .proto.Ingredient ingredients = 3;
inline int Recipe::ingredients_size() const {
  return ingredients_.size();
}
inline void Recipe::clear_ingredients() {
  ingredients_.Clear();
}
inline const ::proto::Ingredient& Recipe::ingredients(int index) const {
  return ingredients_.Get(index);
}
inline ::proto::Ingredient* Recipe::mutable_ingredients(int index) {
  return ingredients_.Mutable(index);
}
inline ::proto::Ingredient* Recipe::add_ingredients() {
  return ingredients_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Ingredient >&
Recipe::ingredients() const {
  return ingredients_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Ingredient >*
Recipe::mutable_ingredients() {
  return &ingredients_;
}

// -------------------------------------------------------------------

// World

// repeated .proto.Item armors = 1;
inline int World::armors_size() const {
  return armors_.size();
}
inline void World::clear_armors() {
  armors_.Clear();
}
inline const ::proto::Item& World::armors(int index) const {
  return armors_.Get(index);
}
inline ::proto::Item* World::mutable_armors(int index) {
  return armors_.Mutable(index);
}
inline ::proto::Item* World::add_armors() {
  return armors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Item >&
World::armors() const {
  return armors_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Item >*
World::mutable_armors() {
  return &armors_;
}

// repeated .proto.Item crafting_materials = 2;
inline int World::crafting_materials_size() const {
  return crafting_materials_.size();
}
inline void World::clear_crafting_materials() {
  crafting_materials_.Clear();
}
inline const ::proto::Item& World::crafting_materials(int index) const {
  return crafting_materials_.Get(index);
}
inline ::proto::Item* World::mutable_crafting_materials(int index) {
  return crafting_materials_.Mutable(index);
}
inline ::proto::Item* World::add_crafting_materials() {
  return crafting_materials_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Item >&
World::crafting_materials() const {
  return crafting_materials_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Item >*
World::mutable_crafting_materials() {
  return &crafting_materials_;
}

// repeated .proto.Recipe recipes = 3;
inline int World::recipes_size() const {
  return recipes_.size();
}
inline void World::clear_recipes() {
  recipes_.Clear();
}
inline const ::proto::Recipe& World::recipes(int index) const {
  return recipes_.Get(index);
}
inline ::proto::Recipe* World::mutable_recipes(int index) {
  return recipes_.Mutable(index);
}
inline ::proto::Recipe* World::add_recipes() {
  return recipes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Recipe >&
World::recipes() const {
  return recipes_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Recipe >*
World::mutable_recipes() {
  return &recipes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_econ_2eproto__INCLUDED
